{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version); // Exported Types\n\nfunction hasMnemonic(value) {\n  return value != null && value.mnemonic && value.mnemonic.phrase;\n}\n\nexport class KeystoreAccount extends Description {\n  isKeystoreAccount(value) {\n    return !!(value && value._isKeystoreAccount);\n  }\n\n}\n\nfunction _decrypt(data, key, ciphertext) {\n  const cipher = searchPath(data, \"crypto/cipher\");\n\n  if (cipher === \"aes-128-ctr\") {\n    const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\n    const counter = new aes.Counter(iv);\n    const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n    return arrayify(aesCtr.decrypt(ciphertext));\n  }\n\n  return null;\n}\n\nfunction _getAccount(data, key) {\n  const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\n\n  if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n    throw new Error(\"invalid password\");\n  }\n\n  const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n  if (!privateKey) {\n    logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"decrypt\"\n    });\n  }\n\n  const mnemonicKey = key.slice(32, 64);\n  const address = computeAddress(privateKey);\n\n  if (data.address) {\n    let check = data.address.toLowerCase();\n\n    if (check.substring(0, 2) !== \"0x\") {\n      check = \"0x\" + check;\n    }\n\n    if (getAddress(check) !== address) {\n      throw new Error(\"address mismatch\");\n    }\n  }\n\n  const account = {\n    _isKeystoreAccount: true,\n    address: address,\n    privateKey: hexlify(privateKey)\n  }; // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\n  if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n    const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n    const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n    const mnemonicCounter = new aes.Counter(mnemonicIv);\n    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n    const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n    const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n    try {\n      const mnemonic = entropyToMnemonic(entropy, locale);\n      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n\n      account.mnemonic = node.mnemonic;\n    } catch (error) {\n      // If we don't have the locale wordlist installed to\n      // read this mnemonic, just bail and don't set the\n      // mnemonic\n      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n        throw error;\n      }\n    }\n  }\n\n  return new KeystoreAccount(account);\n}\n\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n  return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n  const passwordBytes = getPassword(password);\n  const kdf = searchPath(data, \"crypto/kdf\");\n\n  if (kdf && typeof kdf === \"string\") {\n    const throwError = function (name, value) {\n      return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n    };\n\n    if (kdf.toLowerCase() === \"scrypt\") {\n      const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n      const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n      const p = parseInt(searchPath(data, \"crypto/kdfparams/p\")); // Check for all required parameters\n\n      if (!N || !r || !p) {\n        throwError(\"kdf\", kdf);\n      } // Make sure N is a power of 2\n\n\n      if ((N & N - 1) !== 0) {\n        throwError(\"N\", N);\n      }\n\n      const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n\n      return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n    } else if (kdf.toLowerCase() === \"pbkdf2\") {\n      const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      let prfFunc = null;\n      const prf = searchPath(data, \"crypto/kdfparams/prf\");\n\n      if (prf === \"hmac-sha256\") {\n        prfFunc = \"sha256\";\n      } else if (prf === \"hmac-sha512\") {\n        prfFunc = \"sha512\";\n      } else {\n        throwError(\"prf\", prf);\n      }\n\n      const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n      const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n\n      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n    }\n  }\n\n  return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\nexport function decryptSync(json, password) {\n  const data = JSON.parse(json);\n\n  const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n\n  return _getAccount(data, key);\n}\nexport function decrypt(json, password, progressCallback) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const data = JSON.parse(json);\n    const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n  });\n}\nexport function encrypt(account, password, options, progressCallback) {\n  try {\n    // Check the address matches the private key\n    if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n      throw new Error(\"address/privateKey mismatch\");\n    } // Check the mnemonic (if any) matches the private key\n\n\n    if (hasMnemonic(account)) {\n      const mnemonic = account.mnemonic;\n      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  } // The options are optional, so adjust the call as needed\n\n\n  if (typeof options === \"function\" && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  const privateKey = arrayify(account.privateKey);\n  const passwordBytes = getPassword(password);\n  let entropy = null;\n  let path = null;\n  let locale = null;\n\n  if (hasMnemonic(account)) {\n    const srcMnemonic = account.mnemonic;\n    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n    path = srcMnemonic.path || defaultPath;\n    locale = srcMnemonic.locale || \"en\";\n  }\n\n  let client = options.client;\n\n  if (!client) {\n    client = \"ethers.js\";\n  } // Check/generate the salt\n\n\n  let salt = null;\n\n  if (options.salt) {\n    salt = arrayify(options.salt);\n  } else {\n    salt = randomBytes(32);\n    ;\n  } // Override initialization vector\n\n\n  let iv = null;\n\n  if (options.iv) {\n    iv = arrayify(options.iv);\n\n    if (iv.length !== 16) {\n      throw new Error(\"invalid iv\");\n    }\n  } else {\n    iv = randomBytes(16);\n  } // Override the uuid\n\n\n  let uuidRandom = null;\n\n  if (options.uuid) {\n    uuidRandom = arrayify(options.uuid);\n\n    if (uuidRandom.length !== 16) {\n      throw new Error(\"invalid uuid\");\n    }\n  } else {\n    uuidRandom = randomBytes(16);\n  } // Override the scrypt password-based key derivation function parameters\n\n\n  let N = 1 << 17,\n      r = 8,\n      p = 1;\n\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  } // We take 64 bytes:\n  //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n  //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n\n\n  return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(key => {\n    key = arrayify(key); // This will be used to encrypt the wallet (as per Web3 secret storage)\n\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32); // This will be used to encrypt the mnemonic phrase (if any)\n\n    const mnemonicKey = key.slice(32, 64); // Encrypt the private key\n\n    const counter = new aes.Counter(iv);\n    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n    const ciphertext = arrayify(aesCtr.encrypt(privateKey)); // Compute the message authentication code, used to check the password\n\n    const mac = keccak256(concat([macPrefix, ciphertext])); // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\n    const data = {\n      address: account.address.substring(2).toLowerCase(),\n      id: uuidV4(uuidRandom),\n      version: 3,\n      Crypto: {\n        cipher: \"aes-128-ctr\",\n        cipherparams: {\n          iv: hexlify(iv).substring(2)\n        },\n        ciphertext: hexlify(ciphertext).substring(2),\n        kdf: \"scrypt\",\n        kdfparams: {\n          salt: hexlify(salt).substring(2),\n          n: N,\n          dklen: 32,\n          p: p,\n          r: r\n        },\n        mac: mac.substring(2)\n      }\n    }; // If we have a mnemonic, encrypt it into the JSON wallet\n\n    if (entropy) {\n      const mnemonicIv = randomBytes(16);\n      const mnemonicCounter = new aes.Counter(mnemonicIv);\n      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n      const now = new Date();\n      const timestamp = now.getUTCFullYear() + \"-\" + zpad(now.getUTCMonth() + 1, 2) + \"-\" + zpad(now.getUTCDate(), 2) + \"T\" + zpad(now.getUTCHours(), 2) + \"-\" + zpad(now.getUTCMinutes(), 2) + \"-\" + zpad(now.getUTCSeconds(), 2) + \".0Z\";\n      data[\"x-ethers\"] = {\n        client: client,\n        gethFilename: \"UTC--\" + timestamp + \"--\" + data.address,\n        mnemonicCounter: hexlify(mnemonicIv).substring(2),\n        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n        path: path,\n        locale: locale,\n        version: \"0.1\"\n      };\n    }\n\n    return JSON.stringify(data);\n  });\n}","map":{"version":3,"sources":["../src.ts/keystore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport aes from \"aes-js\";\r\nimport scrypt from \"scrypt-js\";\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\r\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\r\nimport { randomBytes } from \"@ethersproject/random\";\r\nimport { Description } from \"@ethersproject/properties\";\r\nimport { computeAddress } from \"@ethersproject/transactions\";\r\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n// Exported Types\r\nfunction hasMnemonic(value) {\r\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\r\n}\r\nexport class KeystoreAccount extends Description {\r\n    isKeystoreAccount(value) {\r\n        return !!(value && value._isKeystoreAccount);\r\n    }\r\n}\r\nfunction _decrypt(data, key, ciphertext) {\r\n    const cipher = searchPath(data, \"crypto/cipher\");\r\n    if (cipher === \"aes-128-ctr\") {\r\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\r\n        const counter = new aes.Counter(iv);\r\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\r\n        return arrayify(aesCtr.decrypt(ciphertext));\r\n    }\r\n    return null;\r\n}\r\nfunction _getAccount(data, key) {\r\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\r\n    const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\r\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\r\n        throw new Error(\"invalid password\");\r\n    }\r\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\r\n    if (!privateKey) {\r\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n            operation: \"decrypt\"\r\n        });\r\n    }\r\n    const mnemonicKey = key.slice(32, 64);\r\n    const address = computeAddress(privateKey);\r\n    if (data.address) {\r\n        let check = data.address.toLowerCase();\r\n        if (check.substring(0, 2) !== \"0x\") {\r\n            check = \"0x\" + check;\r\n        }\r\n        if (getAddress(check) !== address) {\r\n            throw new Error(\"address mismatch\");\r\n        }\r\n    }\r\n    const account = {\r\n        _isKeystoreAccount: true,\r\n        address: address,\r\n        privateKey: hexlify(privateKey)\r\n    };\r\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\r\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\r\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\r\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\r\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\r\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\r\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\r\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\r\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\r\n        try {\r\n            const mnemonic = entropyToMnemonic(entropy, locale);\r\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\r\n            if (node.privateKey != account.privateKey) {\r\n                throw new Error(\"mnemonic mismatch\");\r\n            }\r\n            account.mnemonic = node.mnemonic;\r\n        }\r\n        catch (error) {\r\n            // If we don't have the locale wordlist installed to\r\n            // read this mnemonic, just bail and don't set the\r\n            // mnemonic\r\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n    return new KeystoreAccount(account);\r\n}\r\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\r\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\r\n}\r\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\r\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\r\n}\r\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\r\n    const passwordBytes = getPassword(password);\r\n    const kdf = searchPath(data, \"crypto/kdf\");\r\n    if (kdf && typeof (kdf) === \"string\") {\r\n        const throwError = function (name, value) {\r\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\r\n        };\r\n        if (kdf.toLowerCase() === \"scrypt\") {\r\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\r\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\r\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\r\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\r\n            // Check for all required parameters\r\n            if (!N || !r || !p) {\r\n                throwError(\"kdf\", kdf);\r\n            }\r\n            // Make sure N is a power of 2\r\n            if ((N & (N - 1)) !== 0) {\r\n                throwError(\"N\", N);\r\n            }\r\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\r\n            if (dkLen !== 32) {\r\n                throwError(\"dklen\", dkLen);\r\n            }\r\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\r\n        }\r\n        else if (kdf.toLowerCase() === \"pbkdf2\") {\r\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\r\n            let prfFunc = null;\r\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\r\n            if (prf === \"hmac-sha256\") {\r\n                prfFunc = \"sha256\";\r\n            }\r\n            else if (prf === \"hmac-sha512\") {\r\n                prfFunc = \"sha512\";\r\n            }\r\n            else {\r\n                throwError(\"prf\", prf);\r\n            }\r\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\r\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\r\n            if (dkLen !== 32) {\r\n                throwError(\"dklen\", dkLen);\r\n            }\r\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\r\n        }\r\n    }\r\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\r\n}\r\nexport function decryptSync(json, password) {\r\n    const data = JSON.parse(json);\r\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\r\n    return _getAccount(data, key);\r\n}\r\nexport function decrypt(json, password, progressCallback) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const data = JSON.parse(json);\r\n        const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\r\n        return _getAccount(data, key);\r\n    });\r\n}\r\nexport function encrypt(account, password, options, progressCallback) {\r\n    try {\r\n        // Check the address matches the private key\r\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\r\n            throw new Error(\"address/privateKey mismatch\");\r\n        }\r\n        // Check the mnemonic (if any) matches the private key\r\n        if (hasMnemonic(account)) {\r\n            const mnemonic = account.mnemonic;\r\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\r\n            if (node.privateKey != account.privateKey) {\r\n                throw new Error(\"mnemonic mismatch\");\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n    // The options are optional, so adjust the call as needed\r\n    if (typeof (options) === \"function\" && !progressCallback) {\r\n        progressCallback = options;\r\n        options = {};\r\n    }\r\n    if (!options) {\r\n        options = {};\r\n    }\r\n    const privateKey = arrayify(account.privateKey);\r\n    const passwordBytes = getPassword(password);\r\n    let entropy = null;\r\n    let path = null;\r\n    let locale = null;\r\n    if (hasMnemonic(account)) {\r\n        const srcMnemonic = account.mnemonic;\r\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\r\n        path = srcMnemonic.path || defaultPath;\r\n        locale = srcMnemonic.locale || \"en\";\r\n    }\r\n    let client = options.client;\r\n    if (!client) {\r\n        client = \"ethers.js\";\r\n    }\r\n    // Check/generate the salt\r\n    let salt = null;\r\n    if (options.salt) {\r\n        salt = arrayify(options.salt);\r\n    }\r\n    else {\r\n        salt = randomBytes(32);\r\n        ;\r\n    }\r\n    // Override initialization vector\r\n    let iv = null;\r\n    if (options.iv) {\r\n        iv = arrayify(options.iv);\r\n        if (iv.length !== 16) {\r\n            throw new Error(\"invalid iv\");\r\n        }\r\n    }\r\n    else {\r\n        iv = randomBytes(16);\r\n    }\r\n    // Override the uuid\r\n    let uuidRandom = null;\r\n    if (options.uuid) {\r\n        uuidRandom = arrayify(options.uuid);\r\n        if (uuidRandom.length !== 16) {\r\n            throw new Error(\"invalid uuid\");\r\n        }\r\n    }\r\n    else {\r\n        uuidRandom = randomBytes(16);\r\n    }\r\n    // Override the scrypt password-based key derivation function parameters\r\n    let N = (1 << 17), r = 8, p = 1;\r\n    if (options.scrypt) {\r\n        if (options.scrypt.N) {\r\n            N = options.scrypt.N;\r\n        }\r\n        if (options.scrypt.r) {\r\n            r = options.scrypt.r;\r\n        }\r\n        if (options.scrypt.p) {\r\n            p = options.scrypt.p;\r\n        }\r\n    }\r\n    // We take 64 bytes:\r\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\r\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\r\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\r\n        key = arrayify(key);\r\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\r\n        const derivedKey = key.slice(0, 16);\r\n        const macPrefix = key.slice(16, 32);\r\n        // This will be used to encrypt the mnemonic phrase (if any)\r\n        const mnemonicKey = key.slice(32, 64);\r\n        // Encrypt the private key\r\n        const counter = new aes.Counter(iv);\r\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\r\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\r\n        // Compute the message authentication code, used to check the password\r\n        const mac = keccak256(concat([macPrefix, ciphertext]));\r\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\r\n        const data = {\r\n            address: account.address.substring(2).toLowerCase(),\r\n            id: uuidV4(uuidRandom),\r\n            version: 3,\r\n            Crypto: {\r\n                cipher: \"aes-128-ctr\",\r\n                cipherparams: {\r\n                    iv: hexlify(iv).substring(2),\r\n                },\r\n                ciphertext: hexlify(ciphertext).substring(2),\r\n                kdf: \"scrypt\",\r\n                kdfparams: {\r\n                    salt: hexlify(salt).substring(2),\r\n                    n: N,\r\n                    dklen: 32,\r\n                    p: p,\r\n                    r: r\r\n                },\r\n                mac: mac.substring(2)\r\n            }\r\n        };\r\n        // If we have a mnemonic, encrypt it into the JSON wallet\r\n        if (entropy) {\r\n            const mnemonicIv = randomBytes(16);\r\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\r\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\r\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\r\n            const now = new Date();\r\n            const timestamp = (now.getUTCFullYear() + \"-\" +\r\n                zpad(now.getUTCMonth() + 1, 2) + \"-\" +\r\n                zpad(now.getUTCDate(), 2) + \"T\" +\r\n                zpad(now.getUTCHours(), 2) + \"-\" +\r\n                zpad(now.getUTCMinutes(), 2) + \"-\" +\r\n                zpad(now.getUTCSeconds(), 2) + \".0Z\");\r\n            data[\"x-ethers\"] = {\r\n                client: client,\r\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\r\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\r\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\r\n                path: path,\r\n                locale: locale,\r\n                version: \"0.1\"\r\n            };\r\n        }\r\n        return JSON.stringify(data);\r\n    });\r\n}\r\n//# sourceMappingURL=keystore.js.map"]},"metadata":{},"sourceType":"module"}